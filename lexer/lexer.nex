/[0-9]+/               { println("Integer:", txt()) }
/true/                 { println("true") }
/false/                { println("false") }
/AND/                  { println("AND") }
/NOT/                  { println("NOT") }
/CONTAINS/             { println("CONTAINS") }
/NOT[ \t\n]CONTAINS/   { println("NOT CONTAINS") }
/CurrentTime/          { println("CurrentTime") }
/Number/               { println("Number") }
/List/                 { println("List") }
/[a-zA-Z][a-zA-Z0-9]*/ { println("Variable:", txt()) }
/!=/                   { println("!=") }
/>=/                   { println(">=") }
/<=/                   { println("<=") }
/>/                    { println(">") }
/</                    { println("<") }
/=/                    { println("=") }
/\(/                   { println("(") }
/\)/                   { println(")") }
/\[/                   { println("[") }
/\]/                   { println("]") }
/[ \t\n]+/             { /* eat up whitespace */ }
/'[^']*'/ <            { /* println("begin-of-string") */ }
    /'/                { /* println("string-single-quote") */ }
    /[^']*/            { println("string:", txt()) }
>                      { /* println("end-of-string") */ }
/./                    { println("Unrecognized character:", txt()) }
//
package lexer
type GobuleLexer struct {
    lexer *Lexer
}
func New(input io.Reader) *GobuleLexer {
  return &GobuleLexer{lexer:NewLexer(input)}
}
func (l *GobuleLexer) Run() {
  txt := func() string { return l.lexer.Text() }
  NN_FUN(l.lexer)
}
